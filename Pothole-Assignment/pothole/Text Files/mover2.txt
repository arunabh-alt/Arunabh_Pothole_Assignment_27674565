import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist, PoseStamped
from std_msgs.msg import Int32
from nav_msgs.msg import Odometry
from rclpy import qos
from sensor_msgs.msg import CameraInfo, PointCloud2
import image_geometry

class ObstacleAvoidanceAndPositionTracking(rclpy.node.Node):
    camera_model = None
    def __init__(self):
        super().__init__('obstacle_avoidance_and_position_tracking')

        # Subscriptions for laser scan, position data, and pothole count
        self.scan_subscription = self.create_subscription(LaserScan, 'scan', self.scan_callback, 10)
        self.camera_info_sub = self.create_subscription(CameraInfo, '/limo/depth_camera_link/camera_info',
                                                self.camera_info_callback, 
                                                qos_profile=qos.qos_profile_sensor_data)
        self.position_subscription = self.create_subscription(Odometry, '/odom', self.odometry_callback, 10)
        #self.pothole_count_subscriber = self.create_subscription(Int32, '/total_potholes',
                                                             #    self.pothole_count_callback, 10)

        # Publisher for velocity commands
        self.publisher = self.create_publisher(Twist, 'cmd_vel', 10)

        # Variables for position tracking and pothole counting
        self.starting_position = None
        self.positions = []

        # Twist message for velocity commands
        self.twist = Twist()
        self.initial_position = None
        # Declare parameter only once in the constructor
        self.declare_parameter("total_pothole_count", 0)
        self.initial_movement_timer = self.create_timer(10.0, self.stop_initial_movement)
    def scan_callback(self, msg):
        min_distance = min(msg.ranges[int(len(msg.ranges)/2) -10 : int(len(msg.ranges)/2) +10])
        #print(min_distance)

        if min_distance < 0.55:  # Threshold distance for obstacle detection
            self.twist.linear.x = 0.0  # Stop forward motion
            #self.twist.angular.x=0.2
            self.twist.angular.z = -0.2  # Rotate to avoid obstacle
        else:
            self.twist.linear.x = 0.2  # Move forward
            self.twist.angular.z = 0.1  # No rotation

        self.publisher.publish(self.twist)
        if self.initial_position is None:
            self.initial_position = self.get_current_position()
    def odometry_callback(self, msg):
        # Process odometry data here
        # Access pose and position information from 'msg' object
        pose = msg.pose
        self.current_position = msg.pose.pose
        # position = pose.pose.position
        # orientation = pose.pose.orientation

        # Print or use odometry data as per your requirement
        #self.get_logger().info(f'Odometry - Position: {position}, Orientation: {orientation}')   
    def get_current_position(self):
        return self.current_position    
    def camera_info_callback(self, msg):
        if not self.camera_model:
            self.camera_model = image_geometry.PinholeCameraModel()
        self.camera_model.fromCameraInfo(msg) 

        # camera_matrix = msg.k
        # distortion_coefficients = msg.d

        # # Print or use camera info data as per your requirement
        # self.get_logger().info(f'Camera Info - Camera Matrix: {camera_matrix}, Distortion Coefficients: {distortion_coefficients}')
    def stop_initial_movement(self):
        # Stop the initial movement after 10 seconds
        self.initial_movement_timer.cancel()    
    #def camera_info_callback(self, msg):
        # Process camera info data here
        # Access relevant information from 'msg' object
        
    # def position_callback(self, msg):
    #     current_position = msg.pose.position

    #     # Store the starting position if not already set
    #     if self.starting_position is None:
    #         self.starting_position = current_position

    #     # Store the current position in the list
    #     self.positions.append(current_position)

    #     def reached_ending_point():
    #         x_threshold = 5.0  # Example threshold for x-coordinate
    #         y_threshold = 3.0  # Example threshold for y-coordinate
    #         current_position = self.positions[-1]  # Get the most recent position
    #         return current_position.x >= x_threshold and current_position.y >= y_threshold

    #     if reached_ending_point():
    #         # Process captured positions and publish pothole message (using pothole_counts array if needed)
    #         #print(f"Total potholes detected in the journey: {self.get_parameter('total_pothole_count').value}")
    #         print("Completed")
    #         # Reset variables for the next round
    #         self.starting_position = None
    #         self.positions = []

    # def pothole_count_callback(self, msg):
    #     pothole_count = msg.data
    #     #print(f"Received pothole count: {pothole_count}")

    #     # Retrieve the current count and update the parameter value
    #     current_count = self.get_parameter("total_pothole_count").value
    #     new_count = current_count + pothole_count
    #     self.set_parameters([rclpy.parameter.Parameter('total_pothole_count', rclpy.Parameter.Type.INTEGER, new_count)])
    #     self.get_logger().info(f"Total potholes detected: {new_count}")

def main(args=None):
    rclpy.init(args=args)
    obstacle_avoidance_and_position_tracking = ObstacleAvoidanceAndPositionTracking()
    rclpy.spin(obstacle_avoidance_and_position_tracking)
    obstacle_avoidance_and_position_tracking.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image, CameraInfo
from cv_bridge import CvBridge
import cv2
import numpy as np
from std_msgs.msg import Int32
import hashlib
from rclpy.qos import qos_profile_sensor_data
import image_geometry

# Define a class for the contour detection node
class ContourDetectionNode(Node):
    camera_model = None  # Camera model obtained from camera info message
    cumulative_count = 0  # Cumulative count of detected contours

    def __init__(self):
        super().__init__('contour_detection_node')
        
        # Create subscriptions to image and camera info topics
        self.subscription = self.create_subscription(Image, '/limo/depth_camera_link/image_raw', 
                                                    self.image_callback, qos_profile=qos_profile_sensor_data)
        self.camera_info_sub = self.create_subscription(CameraInfo, '/limo/depth_camera_link/camera_info',
                                                        self.camera_info_callback, 
                                                        qos_profile=qos_profile_sensor_data)
        
        self.cv_bridge = CvBridge()  # OpenCV bridge for image conversion
        self.counts_publisher = self.create_publisher(Int32, 'counts_over_time', 10)  # Publisher for counts over time
        
        # Initialize variables to accumulate counts
        self.counts_over_time = []
        self.tracker = cv2.TrackerKCF_create()
        self.current_potholes = []
        self.occupancy_grid = np.zeros((500, 500), dtype=np.uint8)  # Adjust the grid size as needed

    def image_callback(self, msg):
        try:
            cv_image = self.cv_bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')
        except Exception as e:
            self.get_logger().info(f'Error converting image: {str(e)}')
            return

        # Apply magenta color contour detection
        result = self.detect_magenta_contours(cv_image)
        
        # Display the result
        cv2.imshow('Magenta Contours', result)
        cv2.waitKey(1)
        
        # Publish the count of contours over time
        if len(self.counts_over_time) > 0:
            counts_msg = Int32()
            counts_msg.data = self.counts_over_time[-1]
            self.counts_publisher.publish(counts_msg)

    def detect_magenta_contours(self, image):
        # Convert image to HSV color space
        hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
        
        # Define lower and upper bounds for magenta color
        lower_magenta = np.array([140, 50, 50])
        upper_magenta = np.array([170, 255, 255])
        
        # Create a binary mask for magenta color
        mask = cv2.inRange(hsv, lower_magenta, upper_magenta)
        
        # Find contours in the binary mask
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        result = image.copy()  # Copy of the original image for drawing contours
        unique_pothole_numbers = set()  # Set to store unique pothole numbers
        contours_count = 0  # Count of detected contours
        unique_contours = set()  # Set to store unique contours

        potholes_to_remove = []  # List to store potholes to be removed from current_potholes

        if contours:
            for contour in contours:
                area = cv2.contourArea(contour)

                if area > 1300:  # Filter contours based on area
                    contour_tuple = tuple(contour.flatten())

                    found = False
                    for pothole in self.current_potholes:
                        # Check if the contour matches a previously detected pothole
                        if cv2.matchShapes(contour, pothole['contour'], cv2.CONTOURS_MATCH_I2, 0.0) < 0.5:
                            found = True
                            pothole['tracked'] = True
                            break

                    if not found:
                        # Check against previously detected contours
                        found_similar_contour = False
                        for pothole in self.current_potholes:
                            if cv2.matchShapes(contour, pothole['contour'], cv2.CONTOURS_MATCH_I2, 0.0) < 0.5:
                                found_similar_contour = True
                                break

                        if not found_similar_contour:
                            # New pothole
                            unique_color = self.hash_color(str(contour))
                            cv2.drawContours(result, [contour], -1, unique_color, 2)

                            center = self.get_contour_center(contour)

                            contours_count += 1
                            pothole_number = contours_count +1

                            unique_pothole_numbers.add(pothole_number)
                            unique_contours.add(contour_tuple)

                            self.current_potholes.append({
                                'number': pothole_number,
                                'contour': contour,
                                'tracked': True,
                                'color': unique_color,
                                'center': center
                            })

        # Remove untracked potholes from current_potholes
        for pothole in self.current_potholes:
            if not pothole['tracked']:
                potholes_to_remove.append(pothole)

        for pothole in potholes_to_remove:
            self.current_potholes.remove(pothole)

        # Draw labels for detected potholes
        for pothole in self.current_potholes:
            cv2.putText(result, str(pothole['number']), pothole['center'], cv2.FONT_HERSHEY_SIMPLEX,
                        0.5, (255, 255, 255), 2)

        # Update the cumulative count of detected contours
        self.cumulative_count += contours_count
        self.counts_over_time.append(self.cumulative_count)

        return result

    def get_contour_center(self, contour):
        M = cv2.moments(contour)
        cx = int(M['m10'] / M['m00'])
        cy = int(M['m01'] / M['m00'])
        return cx, cy

    def get_grid_coordinates(self, point, cell_size):
        x, y = point
        grid_x = int(x / cell_size)
        grid_y = int(y / cell_size)
        return grid_x, grid_y

    def camera_info_callback(self, msg):
        self.camera_model = image_geometry.PinholeCameraModel()
        self.camera_model.fromCameraInfo(msg)

    @staticmethod
    def hash_color(text):
        hashed = hashlib.md5(text.encode()).hexdigest()
        r = int(hashed[:2], 16)
        g = int(hashed[2:4], 16)
        b = int(hashed[4:6], 16)
        return r, g, b

    def get_counts_over_time(self):
        return self.counts_over_time

def main(args=None):
    rclpy.init(args=args)
    contour_detection_node = ContourDetectionNode()
    rclpy.spin(contour_detection_node)
    counts_over_time = contour_detection_node.get_counts_over_time()
    print("Counts over time:", counts_over_time)
    rclpy.shutdown()

if __name__ == '__main__':
    main()